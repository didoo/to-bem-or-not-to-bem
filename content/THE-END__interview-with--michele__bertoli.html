---
number: 10
---

{% extends "../templates/pages/interview.html" %}

{% block biography %}

<p>Front End Engineer with a passion for beautiful UIs.</p>
<p>Author of "React Design Patterns and Best Practices" (Packt), he has a degree in computer science, and he loves clean and well-tested code.</p>
<p>Currently, he is working with React.js, crafting modern JavaScript applications, and will be joining the Front End Team at Facebook in 2017.</p>
<!-- <p>Born in Italy, he moved to London with his family to look for new exciting job opportunities. He is a big fan of open source and is always trying to learn something new.</p> -->
<p>He speaks at meetups and conferences: from the jsDay in Italy, through the Front End London, to the React Amsterdam.</p>

{% endblock %}

{% block interview %}

<div class="dialog dialog--question">
    <p>This is the last interview of the project. For this reason I have invited Michele Bertoli.</p>
    <p>&quot;Mee-keh-leh&quot;, as he likes to tell at the beginning of his talks &#x2013; is a dear friend of mine, we are from the same city in Italy, Brescia. He&apos;s been a front-end developer for a long time, and for this reason I absolutely trust his opinions and even more his &quot;instinct&quot;; this means that we are quite used to discuss about methodologies, techniques, new ideas and approaches to our work.</p>
    <p>It was during one of those discussions (we were eating street food for lunch in Hoxton Square) that we ended up debating if BEM was a good choice or not. I was trying to convince him that BEM was not &quot;needed&quot;, that there were other ways to solve the problems it was supposed to solve, while he was explaining me how it made things a lot easier for him and how it was natural to read and understand its syntax after a while.</p>
    <p>In some way this interview is a follow up to that discussion, and the final thoughts for this project.</p>
</div>
<div class="dialog dialog--question">
    <p>–––––––––––––––––––––</p>
</div>
<div class="dialog dialog--question">
    <p>Hello Michele</p>
    <p>Thanks for accepting my invite to close this series of interviews about BEM.</p>
    <p>Now, I won&apos;t ask you what do you think of that discussion and of BEM in general, I&apos;ll come back to it in a moment.</p>
    <p>Now that you&#x2019;ve become for everyone the reference point for <a href="https://github.com/MicheleBertoli/css-in-js">CSS-in-JS</a>, I would like you to introduce yourself. How do you see yourself today? A front-end developer? A CSS developer? A JavaScript developer? A unicorn? :)</p>
</div>
<div class="dialog dialog--answer">
    <p>First of all, thank you very much for inviting me. It&apos;s a pleasure and an honour to be part of this project. I miss our inspirational lunches in Shoreditch so much btw.</p>
    <p>I moved to London two years and a half ago (I literally decided after a three hours call with Cristiano). In Italy, I used to work in <a href="http://gummyindustries.com/">creative agencies</a> where I grew my passion for cool web stuff. Recently, I moved to the <a href="https://www.bizzby.com/">startup</a> <a href="https://yplanapp.com/">industry</a> where I had the opportunity to improve my JavaScript skills, which lead to me being hired by Facebook.</p>
    <p>When I was building my first React application, I realised that the way I used to design and write my CSS wasn&apos;t a good fit for it and I started looking for Modern&#x2122; solutions. I discovered the CSSinJS world thanks to <a href="https://twitter.com/vjeux">vjeux</a> and I wanted to try all the available packages. From that point on, I talk about writing CSS in JavaScript whenever I can.</p>
    <p>I&apos;ve been recently asked to define myself, and I came out with &quot;Front End Engineer with a passion for beautiful UIs&quot; which for me means that I know about big-O notation, but I love writing HTML and CSS.</p>
    <p>Anyway, you were right about BEM :)</p>
</div>
<div class="dialog dialog--question">
    <p>Wow, I&apos;m absolutely shocked!</p>
    <p>I don&apos;t think I was &quot;right&quot; on BEM, in the sense that I was right in principle, but in the practice of everyday&apos;s life I was wrong (and that&apos;s what is important, that&apos;s the reality of our work). At least this is what my experience in the last year (and this series of interviews) has taught me.</p>
    <p>OK, let&apos;s talk about BEM then, and this &quot;to BEM or not to BEM&quot; thing. I know that you were an eager reader of the interviews, but I never asked you anything about them to avoid spoiling this final interview.</p>
    <p>What did you get out of them? What are the &quot;lessons&quot; you have learned, the conclusions you think we can take?</p>
</div>
<div class="dialog dialog--answer">
    <p>Let me explain a little bit more :) You were right saying that BEM was the wrong (unneeded?) solution to the problem. On the other hand, it became the de facto standard, and I find myself comfortable every time I approach a codebase that uses it.</p>
    <p>It is widely adopted and (often) well-understood by developers with different skill sets, which is the biggest win of BEM. I loved this series of interviews since the beginning because it is #forreal.</p>
    <!-- <p>In particular, I believe the format is great because it is more than a typical interview with fixed questions, it&apos;s an informal chat with smart people. The discussion flows naturally, and they share their real experiences. You can read the posts multiple times, and you will always find some new tips.</p> -->
    <p>The key points that emerged from almost all the posts, and contributed to change my mind about the topic, are:</p>
    <p>1 - Pragmatism. You interviewed some of the most skilled people in our industry, and from what they say, avoiding unnecessary formalism is one of the keys to their success.</p>
    <p>2 - &quot;I use BEM but...&quot;. I guess this is a universal opinion. Everyone uses BEM? Nope. Does everyone use their own version of BEM? Exactly. Maybe this is the reason of its diffusion. You can adopt it as a &quot;standard&quot;, you can easily adapt it to the needs of your project/team, and you can still call it BEM.</p>
    <p>3 - Mixing solutions. Using more than one technique seems the way to go. Using BEM with Atomic, and with other approaches, is something that sounds weird if we tend to be strict. Reading this blog, it seems the way to go if you want to ship code.</p>
    <p>4 - Components. Last but not least, I believe this is the central point. Developers adopted BEM because it helped them reasoning about blocks (components?) and elements (components?). Now that we have components, BEM is not needed anymore. In my opinion, this closes the circle.</p>
</div>
<div class="dialog dialog--question">
    <p>&#x201C;Now that we have components, BEM is not needed anymore.&#x201D;. I am pretty sure a lot of people will jump on the chair reading this.</p>
    <p>Personally I agree with you, but only if you slightly change the concept: &#x201C;If you use components, you don&apos;t need BEM anymore&#x201D; where components here is used in the broadest definition as possible (there are many ways to create &quot;web components&quot;, each one with its own pros/cons).</p>
    <p>Regarding web components and CSS &quot;componentization&quot;, nowadays there are many ways to do it especially using Modern&#x2122; solutions (you are the expert, probably you can name dozens of them). In your opinion, which one of them has good chances to become a &quot;de facto standard&quot; like with BEM in the future?</p>
</div>
<div class="dialog dialog--answer">
    <p>I agree: *if you use* components :) And, to quote <a href="06__interview-with--adam__onishi.html">Adam Onishi</a>: (with components) &quot;[...] a lot of what the BEM CSS technique brings to styling will be redundant&quot;. Your question is really interesting, and the answer is not trivial at all.</p>
    <p>In <a href="https://github.com/MicheleBertoli/css-in-js">my repository</a>, I count more than 45 packages. Someone thinks we are all crazy, I strongly believe it&apos;s awesome how in our industry (thanks to the open source) we can create and share experimental solutions to common problems. In this way, we inspire each other and move forward at a very fast pace. Most of the CSSinJS techniques are React-related because React popularised the concept of components and brought a new model of separation of concerns (did you see <a href="https://twitter.com/thomasfuchs/status/810885087214637057">this</a>?), but the majority can be applied to any library or framework.</p>
    <p>My favourite one is CSS Modules, mostly because it&apos;s a non-solution. You need Webpack to make it work, but its behaviour can be easily reproduced with Scoped CSS or Shadow DOM. I like it because it made me write CSS again, without caring so much about naming conventions, complex Sass mixin or variables.</p>
    <p>Components are small and focused, their CSS are simple and easy to maintain. That&apos;s it. I believe CSS Modules (and the concept of &quot;scoped&quot; styles) is here to stay.</p>
    <p>If you want to go a step further, and you compose components with a functional approach, there are the Styled Components. I think Styled Components opened the way to a whole new world. The authors, Glenn Maddern (co-creator of the CSS Modules) and Max Stoiber, really pushed the concept of components to the max. Why create class names that match 1-to-1 your elements, when you can use components? It&apos;s still at the early stage, but I feel that&apos;s the right direction for the future of styling.</p>
</div>
<div class="dialog dialog--question">
    <p>I agree with you, if today I should bet on something it&apos;s CSS Modules :)</p>
    <p>But getting back to what you just said, if you need Webpack or other special tools (in most of the cases) how much is the solution actually influenced by the tooling stack and its evolution? Are you sure we are trying to find &quot;solutions to common problems&quot;, or aren&apos;t we just trying to find the strangest way to avoid to write CSS at all, leveraging the fact that our tools are &quot;programmable&quot; and so we can take any syntax or declaration of sort and convert it to CSS in output?</p>
</div>
<div class="dialog dialog--answer">
    <p>I understand your point, but I think it has always been like that. Aren&apos;t Sass or Less just tools we use to avoid writing CSS? I can&apos;t see any difference, apart from the fact that the new solutions tend to use JavaScript. CSS have been created to style documents, while we build web applications using components. It seems natural to me that something has to change.</p>
</div>
<div class="dialog dialog--question">
    <p>Well, the evolution from CSS to Less/Sass/Stylus etc. has been pretty slick at the end. It&apos;s been a change of syntax and file architecture/organisation, but the core remained the same. While the recent JavaScript-based implementations take the game to a completely new level, they are definitely disruptive. And that&apos;s also why they are so controversial and generate so much &quot;heat&quot; in the community.</p>
    <p>Also, regarding this shift from building web-pages to building web-applications, have you seen <a href="https://twitter.com/sebmarkbage/status/811348741143699457">this tweet</a> by Sebastian Markb&#xE5;ge yesterday?</p>
    <p>Clearly the web is forking, but do you think the web should &quot;concede defeat&quot; to native applications, like PPK suggested? Because in my experience, even in my daily job, I think is the opposite.</p>
</div>
<div class="dialog dialog--answer">
    <p>Today we are used to pre-processors, but the first time I saw one I thought: what kind of sorcery is this? That&apos;s not real CSS, and you lose control over the bundle? Why should I add a build step to my workflow? Gulp or Grunt? We could split and import partials, create mixins, extend classes. Pre-processors completely changed the way we used to approach CSS, but since they didn&apos;t touch the other &quot;concerns&quot; they have been accepted.</p>
    <p>Sebastian&apos;s post is awesome, and I agree when he says that the future of the web is &quot;very interesting&quot;. The web is forking, and I couldn&apos;t be more excited. PPK is on point saying that websites are often over-engineered, and they sometimes offer a bad UX (e.g. scroll hijacking) but I don&apos;t believe the web should &quot;concede defeat&quot;.</p>
    <p>My personal feeling is that the web has a bright future and when the platform (as a whole) will be good enough, we should rethink the role of native applications instead. I recently attended <a href="https://ldnwebperf.org/events/progressive-web-apps-with-jake-archibald/">a talk by Jack Archibald</a>) that blew my mind about how browsers are evolving and how many possibilities we are going to have in the near future.</p>
</div>
<div class="dialog dialog--question">
    <p>Mmm, not sure if I agree with you on the first part of your comment, about pre-processors: of course they introduced new methods of writing CSS, but it was still the same game at the end. But I want to move on, so it&apos;s probably matter for a new discussion at lunchtime.</p>
    <p>I want to come back to what you said above about the &quot;experimental solutions&quot;. I totally get the exploration and inspiration and moving the web forward.</p>
    <p>But then these experimental solutions end up in real production code, in real business products. They enter in the &quot;master&quot; codebase of a company, not only in personal side projects.</p>
    <p>And I don&apos;t have problem with that, as soon as a company is aware of the risks and possible downsides of adopting emerging technologies, that sometimes are mastered only by a few bunch of people, if not in some cases by the one developer inside the company that wants to try something new, cool and Modern&#x2122; and doesn&apos;t care (or realise) that then this code will need to be maintained and updated, possibly for a few years to come.</p>
    <p>Which at the end is what a lot of &quot;old school&quot; developers and ma&#xEE;tre a penser contest: that these approaches and techniques are not sustainable on the long term, they are throwaway methodologies that will be replaced by the next cycle of hype.</p>
    <p>What do you think?</p>
</div>
<div class="dialog dialog--answer">
    <p>Wow, this is a fascinating topic. I have found myself multiple times in the position where I could choose the shiny new technology VS staying safe. I believe that having a high level of seniority :) helped with that, but (as you said) it&apos;s always a risky decision for the company.</p>
    <p>I guess it also highly depends on the industry. For example, when I used to work in creative agencies on short-term projects (e.g. marketing campaigns) I was asked to choose the latest crazy cool stuff. Then I moved to startups where projects are potentially (and hopefully) long-terms, but you still bet every single day on the future of the product.</p>
    <p>I firmly believe there should always be a reason for investing in experimental solutions, and that reason should not be that someone tweeted about it.</p>
    <p>To accurately answer your question, I would like to share my personal experience (which is the essence of this project). At <a href="https://yplanapp.com/">YPlan</a>, my previous company, I was leading the front-end team, and we have been asked to create a &quot;framework&quot; which we could use to build new UIs quickly. We were developing a new Portal for our partners, and we used to work iteratively, doing a lot of user testing.</p>
    <p>For that reason, we wanted to be able to create and destroy interfaces without wasting time and iterate fast. Our primary product was built with React and Sass+BEM. We decided (of course :)) to keep React, but we wanted to take a step further on the componentization and avoid following a naming convention.</p>
    <p>The natural solution was CSS Modules. I believe that moving to CSS Modules doesn&apos;t require to be brave because, with a simple command, you can extract the CSS (tweaking the class names as you wish).</p>
    <p>The &quot;crazy&quot; part was when we decided to try the Atomic CSS. I heard (at FEL) that, with Atomic CSS, you could prototype UIs quickly and that was exactly our goal. On the other hand, we didn&apos;t want to pollute the markup with tens of classes. That&apos;s why we decided to use <a href="https://medium.com/yplan-eng/atomic-css-modules-cb44d5993b27#.3jntjcgpo">CSS Modules to compose our Atomic classes</a> inside the CSS.</p>
    <p>How did we know that was a good solution? How could we make sure we weren&apos;t creating a technical debt? The first step we took has been building a prototype to see if the solution could work and it was flexible enough to cover all the cases. At that point, the most important thing was for everyone in the team to agree. We shared the demo with the rest of the company, and people was impressed with the speed in which we could create and destroy interfaces (keeping the size of the CSS under control).</p>
    <p>When everyone is on board, the second thing I learned is to fail fast. Go and build the most sophisticated interface and see how it goes, don&apos;t wait for the experimental solution to pollute your codebase. Timeout has now acquired the startup and lot of new developers are going to work on the codebase.</p>
    <p>My ex-colleague <a href="https://twitter.com/elmotta">Lucas</a> had to do the handover but since we documented all the decisions with blog posts and presentations he didn&apos;t have any problems.</p>
    <p>To recap, the key points are: - bet on experimental solutions only if they solve a real problem - get everyone on board and document your decisions - fail fast and prepare a backup plan. It worked very well for us :)</p>
</div>
<div class="dialog dialog--question">
    <p>Now, let me be the devil&apos;s advocate here, because you were too good in your answer (probably because it&apos;s Christmas).</p>
    <p>Recently I have started to ask myself if all this &quot;code quality&quot;, and clean codebase, and refactoring to reduce the technical debt are just myths, or illusions.</p>
    <p>What I have seen are two kind of projects: those that once created and deployed are left there untouched forever, and those that are then maintained day by day, month by month, accumulating workarounds and patches and &quot;we&apos;ll fix later&quot;, and a whole team dreaming of a future moment in which there will be time to do things properly.</p>
    <p>But this time never comes because the company collapses (see VisualDNA), gets acquired (see Yplan) or decides to completely re-design the product, and at that point the old codebase is simply ditched and a new clean &quot;master&quot; branch sees the light, just to end up in the same situation a few months later.</p>
    <p>So all this principles of maintainability, future-proof code, technical choices that can span years of lifecycle of a product, are just a gimmick.</p>
    <p>At the end if our code is throwaway, why should we bother to write clean code, to fight against the technical debt, to imagine architectures and introduce methodologies and care about the code?</p>
    <p>Why in that sense Sass+BEM is a better choice compared to CSSinJS, if both are destined to never be touched again or be replaced in a few months? (I remember reading somewhere that typically there is a complete redesign/refactoring of a project every 12-16 months, and that resonates a lot with my experience)</p>
</div>
<div class="dialog dialog--answer">
    <p>I can confirm I&apos;ve only seen those two types of projects in my career, too. I always thought I would find the long-lived well-architectured codebase sooner or later. Maybe in my next experience :)</p>
    <p>However, to me, the technical debt doesn&apos;t only apply to the long term (years). How quick is it to change the code you wrote this morning? That&apos;s why, for example, I prefer to use a tool like CSS Modules that scopes the class names for me rather than a methodology, such as BEM, that makes me overthink and spend time on non-so-important things.</p>
    <p>I like to focus on building features and creating value for the users; that&apos;s it. My goal is writing code that is easy to delete.</p>
</div>
<div class="dialog dialog--question">
    <p>Reading the interviews, and you also noticed it, one thing stands out: everyone tends to pick and choose (and adapt/customise) different parts from different methodologies. BEM + OOCSS + Atomic, BEM + Helpers + OOCSS, etc.</p>
    <p>Is it the same also with Modern&#x2122; CSS? For example you have mixed <a href="https://medium.com/yplan-eng/atomic-css-modules-cb44d5993b27#.bgnitu99f">CSS Modules and Atomic</a>. In general do you see people use different approaches and mix them together? Or instead there are clear choices, where one exclude the other?</p>
    <p>And this also leads to a second question, related to being &quot;strict&quot; or &quot;loose&quot; in how you use these methodologies: everyone does BEM-ish, people use BEM but with &quot;exceptions&quot; and &quot;special cases&quot;.</p>
    <p>All the naming conventions and CSS methodologies rely on a strong self-discipline of the developers (especially in a team work with a shared codebase).</p>
    <p>Is it the same for the CSSinJS, CSS Modules and so on? Or each developer can choose his/her own syntax flavour and this is not a problem because somehow is confined inside a component?</p>
</div>
<div class="dialog dialog--answer">
    <p>Yes, not being strict and mixing methodologies was one of the most surprising things I learned reading these interviews.</p>
    <p> I always felt guilty when I couldn&apos;t follow the rules for some reasons, and hearing that strong skilled people are doing that made me feel better :)</p>
    <p>In the CSSinJS world, we talk more about technologies than methodologies. For example mixing Atomic and CSS Modules is more similar to mixing Atomic and Sass, rather than Atomic and BEM.</p>
    <p>In general, I can see people choosing one library and sticking to it. A typical pattern is creating a layer between components and the styling library in a way that components are not aware of it, and it can be replaced easily. For safety, I guess. The fact that CSSinJS are libraries, also means that usually there are no rules or conventions to follows.</p>
    <p>As you said, with these solutions styles tend to be small and focused and there&apos;s no need for creating complex architectures. This is one of the reasons I believe regular CSS are not the perfect fit for components while locally scoped classes or &quot;inline styles&quot; (co-locating styles within the components) work better.</p>
    <p>If you split the components in the right way, you end up having a few styling rules for each one of them and the maintainability is not a problem anymore.</p>
    <p>Additionally, most of the solutions generate the class names for you using unique hashes which mean that you can use whatever naming convention you prefer.</p>
    <p>For example, you can call a button just &quot;button&quot; :)</p>
</div>
<div class="dialog dialog--question">
    <p>That&apos;s why I like so much the idea of CSS Modules. But trust me, you can do the same with BEM or even only with a correct name-spacing. But I have realised (sometimes the hard way) that this doesn&apos;t work well when there is more than one developer involved in a project, or at least if not all the members of the team follow the same rules ;)</p>
</div>
<div class="dialog dialog--question">
    <p>Now, in the last few months there&apos;s been a mounting friction between those who see CSS as one distinct untouchable layer in the &quot;separation of concerns&quot; paradigm, and those who have simply ignored this golden rule and found different ways to style the UI.</p>
    <p>And this debate is getting more and more intense, fiery and harsh every day. I don&apos;t know if you feel you&apos;re on one side, and if you&apos;ve been affected by this &quot;war&quot; being the CSSinJS representative.</p>
    <p>What can we do to to help these two parts to understand and listen each other, see the counterpart&apos;s points of view? Do you think there is something practical we can do now, today? Or is just a matter of waiting and time will tell who was right and who was wrong?</p>
</div>
<div class="dialog dialog--answer">
    <p>I&apos;ve been facing this issue more and more often recently. People tend to fight for no reason on the internet, and &quot;framework wars&quot; are very hot. When it comes to the CSS in JavaScript topic, people often tell me: &quot;you should learn how to write real CSS!&quot;.</p>
    <p>At the beginning of my talks, I always say that Inline Styles (and React) have been communicated in a very strong way. They announced it like &quot;Hey, this is the new cool thing - forget what you learned in the last 15 years&quot; and this doesn&apos;t help.</p>
    <p>I gave a talk called &quot;<a href="https://vimeo.com/136912285">Unlearn Everything</a>&quot; where I tried to introduce this mental change, which I experienced myself when I started. At the end of my talks I also say &quot;Most importantly: have fun!&quot; because the attendees tend to get angry whenever the golden rules of web development are put into discussion.</p>
    <p>If you think about it, it&apos;s awesome how we put so much passion into our job, but it is also counterproductive. We should understand that we are all trying to improve our industry. There&apos;s not an absolute right way of doing stuff on the web, and everyone should aim for the local maximum within their teams and projects.</p>
    <p>Unfortunately, we can&apos;t do too much to fix it I guess. Apart from creating more blogs like this :)</p>
</div>
<div class="dialog dialog--question">
    <p>2017 will be a great year for you: developer at Facebook, speaker at React Amsterdam, author of a new book on React. Can you tell us more about your new adventures?</p>
</div>
<div class="dialog dialog--answer">
    <p>It looks like all the decisions (conscious and unconscious) I made in my entire career are converging into a wonderful 2017.</p>
    <p>Joining Facebook is a dream to me, I still can&apos;t believe it&apos;s true. As a Front End Engineer in love with React, I couldn&apos;t be more excited to be part of one of the companies that are pushing the best open source code, and creating one of the best communities ever around their tools. Having the opportunity to work with smart people on a platform that is changing people&apos;s lives is the best I can think of in terms of career.</p>
    <p>Talking at the <a href="https://react.amsterdam/">React Amsterdam</a> and, more generally, travelling to talk about the things I&apos;m passionate about and meet new people, is fantastic. We should never forget how lucky we are with our job.</p>
    <p>Last but not least, my book &quot;<a href="https://www.amazon.co.uk/React-Design-Patterns-Best-Practices/dp/1786464535">React Design Patterns and Best Practices</a>&quot; is going to be published in a few weeks.</p>
    <p>I&apos;ll do my best to deserve all the excellent opportunities that are happening in my life. I&apos;ll keep on putting passion in my job, giving back to the community and I&apos;ll never forget the first time I met you and the WEBdeBS people. That single moment changed my life forever.</p>
</div>
<div class="dialog dialog--question">
    <p>Well, you certainly deserve all this success :) and never forget, you changed my life too.</p>
    <p>I think we can close the interview here. You are the living example that one can choose to follow the mainstream, let's say to use BEM, or to take a different path, let's say not to use BEM, and doing so come up with new solutions and "rules", that maybe in the future will become the new best practices that everyone will follow.</p>
    <p>What remains is the excitement, the passion and the desire of people like you to always move the web forward and keep the front-end development one step ahead.</p>
    <p>Thank you, Michele.</p>
</div>

{% endblock %}
